<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DBMS Review]]></title>
    <url>%2F2018%2F10%2F02%2FDBMS-Review%2F</url>
    <content type="text"><![CDATA[DBMS Exam2 ReviewStructured Query Language (SQL) - Lecture 11SQL is the standard relational database language and is related to the tuple relational calculus.Standard enables easier switch to other DBMS, queries remain unchanged. Main objectives Create the database and relation structures Perform basic data management tasks, such as insertion, modification, and deletion of data from the relations Perform both simple and complex queries Be portable between different DBMS Perform the aforementioned services with minimal user efforts Perform the aforementioned services with maximum performance Components of SQL: Data Definition Language (DDL): Commands for creating and changing the data structures for the three levels of a database. Data manipulation language (DML): Update commands for tuples, interactive formulation of queries. Embeded SQL and Dynamic SQL; Integrity; View Definition; Transaction Control Authorization. SQL Data Types:Start at Page9. Integrity Constraints and Default Values Integrity constraints are the most important commands of the DDL: are conditions that restrict the possible database states; ensure the consistency of a database; It is recommended to specify the not null condition explicitly for each primary key, although this holds implicitly already for each primary key Default values can be attaching the clause default &lt;value&gt; to the attribute definition. Will be set for every tuple if no explicit value declares. Otherwise, all will be null. Primary Keys The clause primary key (A1, …, An) specifies that the attributes (A1, …, An) form the primary key of the relation R with respect to R. The set of selected attributes must be unique and minimal; Structured Query Language (SQL) - Lecture 12Foreign Keys: A foreign key value references (“points to”) a primary key value in another relation to represent an m:1-relationship of an E-R diagram; Definition of a foreign key by the foreign key clause Foreign keys ensure referential integrity, that is, there are no inconsistent or dangling references A foreign key can or cannot become (part of) the primary key of the relation schema into which it is imported. Candidate Keys: Any unique and minimal set of attributes that could serve but has not been selected as a primary key; The fact that the attributes A1, …, An form a candidate key is specified by the integrity constraint ++unique++ (A1, …, An). SQL DDL Commands Examples of Creation of a Relation Schema/Table Schema: 1234567891011121314151617181920212223242526272829303132create table professors(pers-id int not null, name varchar(30) not null, room int unique, rank char(2), primary key (pers-id)); create table lectures (id int not null, title varchar(30), credits int, held_by int, primary key(id), foreign key (held_by) references professors(pers-id));``` - Modification of a Relation Schema/Table Schema: ```sql//Adding an attribute(a new column) to an existing relation--All tuples in the relation are assigned null as the value for the new attribute--Constraint not null is only allowed if a default value is specifiedalter table &lt;relation name&gt; add &lt;column definition&gt;;//Deleting an attribute (a column) from an existing relation--Command will be declined if integrity constraints would be violatedalter table &lt;relation name&gt; drop &lt;column name&gt;;//Deletion of the schema and instance (that is, data) of a relationdrop table &lt;relation name&gt;//Deletion of the instance (that is, data) of a relation but not its schemadelete from &lt;relation name&gt; Creation of an Index: An index is a persistent data structure that provides accelerated access to the rows of a table based on the values of one or more attributes; Goal: Significant improvement of query response time12create unique index room_index on professors (room);drop index &lt;index name&gt;; Creation of Views: A ++view++ is a virtual relation that does not exist persistently in the database but can be produced upon request by a particular user, at the time of request; Views are regarded as derived relations which are defined by queries:12345--create view &lt;view name&gt; [(&lt;attribute name&gt; [, &lt;attribute name&gt;]*)] as &lt;subquery&gt;creat view major_students as select * from students where sem&gt;4;--delet viewsdrop view &lt;view name&gt;; SQL Queries (DML) Commands - Lecture 13 Basic Structure of SQL Queries: 12345678910/*A1..An are attributes names(columns), R1..Rn are table names, F is predicate,query result is always a single table, no duplicateselect = projectionfrom = cartesian productwhere = selectiondistinct = remove duplicate tuples*/select distinct A1, A2,..., Anfrom R1, R2,... Rnwhere F;--More details in Page2, Lecture13 Basic RA expressions and SQL: 12345678910111213141516171819--show all from Rselect * from R;--Projection A,B from Rselect distinct A, B from R;--selection basing on F from Rselect distinct * from R where F;--Cartesian product of RxSselect * from R, S;--Union R u S of the relations R(A1,..An) and S(A1..An)--This union operation will eliminate duplicates, add "all" after union can keepselect * from R union select * from S;--Difference R - S--Same as above, add "all" after except to keep duplicatesselect * from R except select * from S; SQL queries in sigle table: 12345678--Search Queries--where clause - horizontal (row) restriction--select clause - vertical (column) restrictionselect pers-id, name from professors where rank = "C4";-- Create a students table where the semester number of each student is incremented by 1select reg-id, name, sem+1from student; SQL queries in multiple tables 12345678910111213141516171819202122232425262728293031323334--Determine the names of professors who hold lectures, and show the titles of the corresponding lecturesselect name, titlefrom professors, lectureswhere pers-id = held_by;select name, title from professorsjoin lectures on pers-id=held_by;--Determine the names of professors who hold the lecture titled “maieutics”.select name, titlefrom professors, lectureswhere pers-id = held_by andtitle = ‘maieutics’;--Which students attend which lecture? Output student names and lecture titles. 3 tables nature joinselect name, titlefrom students, attends, lectureswhere students.reg-id = attends.reg-id andattends.id = lectures.id;select name, titlefrom students natural join attends natural join lectures--Rename, "as" is optionalselect s.name, l.titlefrom students as s, attends as a, lectures as lwhere s.reg-id = a.reg-id and a.id = l.id;--List all students together with their performed tests by maintainingthe complete student information.--left outer join reserves all the tuples of left tables--Right outer join (right outer join) and full outer join (full outer join) are similarselect s.*, t.* --can be written as select *from students s left outer join test t on s.reg-id = t.reg-id; Set operations: 123456789101112131415161718192021222324252627282930313233--Determine the names of all university employees, i.e., the names of all professors and all assistants. All duplicates are removed--add "all" after union to keep duplicates(select name from assistants)union(select name from professors);--Find the identifiers of professors who teach “ethics” or “maieutics”.(select p.pers-id from professors p, lectures lwhere p.pers-id = l.held_by and l.title = ‘ethics’)union(select p.pers-id from professors p, lectures lwhere p.pers-id = l.held_by and l.title = ‘maieutics’);--Find the identifiers of professors who teach “ethics” and “maieutics”.(select p.pers-id from professors p, lectures lwhere p.pers-id = l.held_by and l.title = ‘ethics’)intersect(select p.pers-id from professors p, lectures lwhere p.pers-id = l.held_by and l.title = ‘maieutics’);--Find the identifiers of professors who teach “ethics” but not “maieutics”.(select p.pers-id from professors p, lectures lwhere p.pers-id = l.held_by and l.title = ‘ethics’)except(select p.pers-id from professors p, lectures lwhere p.pers-id = l.held_by and l.title = ‘maieutics’);/*Operations union, except, and intersect produce tables as sets of tuples,elimination of duplicatesOperations union all, except all, and intersect all maintain duplicates inresult table*/ SQL Queries Commands - Lecture 14 Update of Tuples in a Table 1234567891011121314151617181920212223Syntax: update &lt;relation name&gt;set &lt;attribute name&gt; = &lt;expression&gt;[, &lt;attribute name&gt; = &lt;expression&gt;]*[where &lt;condition&gt;];--Change room number (currently 232) of professor Russel to 115 update professors set room = 115 where name = ‘Russel’--The construct case is used to perform several updates in a single update statement--Example: Reorganization of the individual assistants’ offices into open-plan officesupdate assistantsset room = case when room &gt;= 100 and room &lt; 120 then 417 when room &gt;= 120 and room &lt; 140 then 438 else 455end;--Deletion of Tuples in a Table--Delete students who study longer than 8 semestersdelete from students where sem &gt; 8;--Delete all tests tuplesdelete from tests;--Lecture “foundations” with the identifier 5001 was suddenly canceled; delete all registrationsdelete from attends where id = 5001; Aggregate Functions: 12345--Aggregate functions are functions that take a collection (list) of values as--input and return a single value as output--5 bult-in: count, avg, sum, max, min;--Query 4: Calculate the number of different semesters the students are in, and store the result in a new attribute named “diff_sem”.select count(distinct sem) from students; GroupingPage12, Lecture14 12345678910111213141516171819202122232425262728--Determine the number of hours per week in which each professor has given lectures.select held_by, sum(hpw) as numberfrom lecturesgroup by held_by;--Determine the number of hours per week of those lectures held by--professors who predominantly give long lectures (&gt; 3 hours per week on average).select held_by, sum(hpw) as numberfrom lecturesgroup by held_byhaving avg(hpw) &gt; 3;/*General formselect [distinct] &#123;* | &lt;column expression&gt; [as &lt;new column name&gt;] [, …]&#125;from &lt;table name&gt; [as &lt;variable] [, …][where &lt;condition&gt;][group by &lt;column list&gt;having &lt;condition&gt;]][order by &lt;column list&gt;];Sequence of processingselect: specifies which attributes are to appear in the outputfrom: specifies the table or tables to be usedwhere: filters the tuples subject to some conditiongroup by: forms groups of tuples with the same grouping attribute valuehaving: filters the groups subject to some conditionorder by: specifies the order of the output*/ SQL Queries Commands - Lecture 15 Nested Queries Teset for Set Membership in the WHERE clause 123456789101112131415161718key words are "in" and "not in"--Query 1: Output the names of students who have taken a test.select namefrom studentswhere reg-id in (select reg-id from tests);--Query 2: Find the names of all professors that are not involved in teaching.select namefrom professorswhere pers-id not in (select held_by from lectures);--Query 3: Select the names of assistants whose names are neither ‘Platon’ nor ‘Newton’.select namefrom assistantswhere name not in ('Platon', 'Newton');--Query 4: Find the names of all professors who gave a test--and also taught the lecture that was tested.select name from professorswhere pers-id in (select held_by from lectures where (id, held_by) in (select id, pers-id from tests)); Set Comparisons in the WHERE Clause 123456789101112131415161718Key words are "some" and "all"--Query 5: Find the names of all students whose semester number is greater--than at least one of the semester numbers of the students ‘Fichte’--(10th semester) or ‘Carnap’ (3rd semester).select name from studentswhere sem &gt; some (select sem from students where name = ‘Fichte’ or name = ‘Carnap’);--Find the students with the largest number of semesters.select name from studentswhere sem &gt;= all (select sem from students);--Query 7: Find the identifiers of professors who teach the most.select held_byfrom lecturesgroup by held_byhaving sum(hpw) &gt;= all (select sum(hpw) from lectures group by held_by); Test for Empty Tables in the WHERE Clause 12345678910111213141516171819202122--Determine the identifiers of all students who have taken a test.select reg-idfrom students as swhere exists (select * from tests as t where t.reg-id = s.reg-id);--Output the names of professors who do not hold lectures.select namefrom professorswhere not exists (select * from lectures where pers-id = held_by);--“Table A contains table B” is the same as “not exists(B except A)”--Output the names of students who attend all lectures offered by professor Curie.select s.namefrom students as swhere not exists ((select id from lectures, professors where pers-id = held_by and name = ‘Curie’) except (select l.id from attends as a, lectures as l where l.id = a.id and a.reg-id = s.reg-id) ); Test for the Absence of Duplicate Tuples in the WHERE Clause 12345678910--The unique construct returns the value true if the table as the result of the--argument subquery contains no duplicate tuples--Determine the names of professors who have at most one assistant working for them.select name from professors as pwhere unique (select a.boss from assistants a where p.pers-id = a.boss);--The not unique construct returns the value true if the table as the result of--the argument subquery contains duplicate tuples--Determine the names of professors who have at least two assistants working for them.select name from professors as pwhere not unique (select a.boss from assistants where p.pers-id = a.boss); Subqueries in the FROM Clause 1234--Output the identifiers of those lectures that are attended by more than 20 students.select idfrom (select id, count(*) as number from attends group by id)where number &gt; 20; The WITH Clause for Defining Temporary Tables 12345678910--A way of defining a temporary table whose definition is available only to the--query in which the with clause is used--Output the titles of those lectures that are attended by more than 20 students.with attendance_rate(id, number) as(select id, count(*) from attends group by id) select l.titlefrom lectures as l, attendance_rate as awhere l.id = a.id and a.number &gt; 20; Scalar Subqueries in the WHERE, SELECT, or HAVING Clause 12345678910111213--A scalar subquery returns a single tuple that consists of a single column and--a single row and that is interpreted and used as a single value--Determine the name and semester number of those students with a semester number less than the average.select name, semfrom studentswhere sem &lt; (select avg(sem) from students);--List the name and semester number of all students whose--semester number is greater than the average semester number,--and compute by how much their semester number is greater than--the average.select name, sem, sem – (select avg(sem) from students) as semDifffrom studentswhere sem &gt; (select avg(sem) from students); Views Disadvantages &amp; QBE - Lecture 16 Views Disadvantages: Structure restriction The structure of a view is determined at the time of its creation The structure of view will be corresponded to the attributes of base table No update if attributes are modified. Performance View resolution that is complex will take long time View Materializtion as a solution. Store the view result as a temporary table in database. Autorization Page3 - Page8 Queries by Example (QBE) Has a two-dimensional Syntax Queries are expressed “by example” Is based on the domain relational calculus: variables are bound to attribute domains (domain variables). Database schema used in examples:customer(++cname++, caddr, account)order(++cname++, ++product++, amount)vender(++vname++, vaddr, ++product++, price) customer cname caddr account — P. P. &lt;0 Language elements Commands: eg. P.(print), I.(insert), D.(delete), U.(update) Example elements, domain variable: _X, _Meyer Constants: Smith, 123 Boolean (e.g. and, or, not), arithmetic (e.g. +, -, *, /) and relational operators(e.g. =, &lt;, &gt;, &lt;&gt;, &gt;=, &lt;=) QBE will perform duplicate elimination automatically;Using all to suppress duplicate elimination. -&gt; P.ALL. Find for each product the name(s) of the cheapest vendor.|vender|vname|vaddr|product|price||:-:|:-:|:-:|:-:|:-:||null|P._n|null|_W|_p||非|_m|null|_w|&lt;_p| QBE - Lecture 17 - Page1-25 Condition Box: contains expression of general constraints with and and or 非符号：用在表头代表『不存在』，用在变量代表『不等于』 Aggregation: SUM., AVG., MAX., MIN., CNT. Usually follows with “ALL.”, with duplicates add “UN” before “ALL.” to remove duplicates. Grouping: G. Ordering: in ascending order: P.AO.; in descending order: P.DO. “I”, “U”, “D” for insertion, update, deletion of tuples. Creation of Table schemas, Page24]]></content>
      <categories>
        <category>DBMS</category>
      </categories>
      <tags>
        <tag>review</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Tree Problems Summary]]></title>
    <url>%2F2018%2F10%2F01%2FLeetCode-Tree-Problems-Summary%2F</url>
    <content type="text"><![CDATA[Preorder100. Same Tree 可套用模板，双pre 123456789101112public boolean isSameTree(TreeNode p, TreeNode q) &#123;if(p == null &amp;&amp; q == null) return true;if(p == null || q == null) return false;if(p.val != q.val) return false;return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);&#125; 101. Symmetric Tree Preorder SameTree拓展 判断root的两个子树是不是sameTree 12345678public boolean isSymmetric(TreeNode root) &#123;if(root == null) return true;return isSameTree(root.left, root.right);&#125; 572. SubTree of Another Tree SameTree拓展 先判断是不是sameTree，然后递归调用一半左一半右 257. Binary Tree Paths DFS preOrder模板，判断null返回，判断叶子加上val，每递归一层加上-&gt;+val 112. Path Sum + 113. Path Sum II + ==437. Path Sum III== PathSum: 双pre，判断叶子，return用or连接左右递归 PathSumII: 顺序preOrder，==两个递归完成后进行==list.remove(list.size()-1) ++PathSumIII: Solution 顺序Pre加上prefixSum的HashMap++ 129. Sum Root to Leaf Numbers 双pre，左递归+右递归，每一层的值是10 * x + root.val，遇叶子返回 298. Binary Tree Longest Consecutive Sequence 顺序Pre，传参sum，每到一个节点判断val是否连上，连上的话sum++，连不上的话sum=1（重置sum） 判断sum之后要进行maxRes操作，取当前最大值作为res (res是全局变量) 111. Minimum of Binary Tree 顺序pre，叶子节点更新minRes，参照最大深度的双pre，两种方法都能做 654. Maximum Binary Tree DFS，顺序pre，传参start, end，找start，end中的最大值建root，然后顺序递归，左start，max-1，右max+1，end BFS, Solution Code-solution)，要用Deque做 Postorder226. Invert Binary Tree (Postorder+BFS) BFS，level order traversal，用queue DFS, 顺序postOrder，实例化递归返回leftNode和rightNode，中点位置进行对调操作，返回root 104. Maximum Depth of Binary Tree DFS, 可以参照111. MinimumDepthOfBT来顺序递归，叶子更新maxRes 也可以双post？ 不传参的话==return Math.max(helper(root.left), helper(root.right))+1==，传参level的话每次调用level+1,返回左右最大值 110. Balanced Binary Tree DFS, 基于MaximumDepth，顺序post，在helper函数中实例left和right的maxDepth，然后root处进行判断，返回的是 ==Math.max(l, r)+1== 116. Populating Next Right Pointers in Each Node BFS, LevelOrder DFS, preOrder，中节点处操作左右next, root.right.next = root.next.left 236. Lowest Common Ancestor of Binary Tree DFS, 顺序postOrder，终结条件：判断为空或者p q时return root， 实例化左右递归，操作中节点时，进行三重判断 1234567891011121314151617181920public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;if(root == null || root == p || root == q)return root;TreeNode left = lowestCommonAncestor(root.left, p, q);TreeNode right = lowestCommonAncestor(root.right, p, q);if (left != null &amp;&amp; right != null) return root;else if (left == null) return right;else return left;//return left != null &amp;&amp; right != null ? root : (left != null ? left : right);&#125; 124. Binary Tree Maximum Path Sum DFS，顺序postOrder，在中节点处维护一个maxRes helper函数记录在每个中节点处的1. maxRes 2.返回该节点左右子树的累计最大值加上自己的val 1234567891011121314private int helper(TreeNode root, int[] res)&#123;if (root == null) return 0;int left = Math.max(0, helper(root.left, res));int right = Math.max(0, helper(root.right, res));res[0] = Math.max(res[0], left+right+root.val);return Math.max(left, right)+root.val;&#125; 250. Count Univalue Subtrees 题意是求多少个相同val的子树，所以要看每个根节点，两种情况1. 左右都null 2. 左右和根节点val相同 DFS，顺序postOrder，return boolean，传参根节点val，实例化递归左右子树 在根节点判断左右Boolean值，返回并判断根节点val和父亲val是否相等 12345678910111213141516171819202122private boolean count(TreeNode root, int[] counter, int val) &#123;if (root == null) &#123;return true;&#125;boolean l = count(root.left, counter, root.val);boolean r = count(root.right, counter, root.val);if (l &amp;&amp; r) &#123;counter[0]++;&#125;return l &amp;&amp; r &amp;&amp; root.val == val;&#125; 366. Find Leaves of Binary Tree 带高度的postOrder 很重要 123456789101112131415161718private int helper(List&lt;List&lt;Integer&gt;&gt; res, TreeNode root)&#123;if (root == null) return -1;int leftHeight = helper(res, root.left);int rightHeight = helper(res, root.right);int rootHeight = Math.max(leftHeight, rightHeight)+1;if (res.size() == rootHeight) res.add(new ArrayList&lt;&gt;());res.get(rootHeight).add(root.val);return rootHeight;&#125; 337. House Robber III 这是一个分情况返回累加最大值的问题，helper内初始化一个变量，最后返回 在左右子树时计算选择隔行的情况，在中节点出计算选择下一行的情况，最后返回较大值 12345678910111213141516171819202122private int helper(TreeNode root)&#123;int left = 0, right = 0;if (root == null) return 0;if (root.left != null)&#123;left += helper(root.left.left)+helper(root.left.right);&#125;if (root.right != null)&#123;right += helper(root.right.left)+helper(root.right.right);&#125;return Math.max(root.val+left+right, helper(root.left)+helper(root.right));&#125; BFS107. Binary Tree Level Order Traversal II 考LinkedList的addFirst操作，声明的时候要LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); 103. Binary Tree Zigzag Level Order Traversal Level Order Traversal，加个boolean判断左右 199. Binary Tree Right Side View (BFS+Preorder) BFS, 用Queue进行level order tarversal，每当poll出最后一个node时添加到res中 DFS, preOrder，递增变量是树的level (start from 0), 每当queue.size() == level时，就添加当前root 123456789101112void helper(TreeNode root, List&lt;Integer&gt; res, int level)&#123;if(root == null) return;if(level == res.size()) res.add(root.val);helper(root.right, res, level+1);helper(root.left, res, level+1);&#125; BST98. Validate Binary Search Tree 考察BST的性质，从root来看，左半边子树都比root小，右半边子树都比root大，所以可以传参min和max DFS，双pre，在中节点处判断是否满足条件，（min和max声明为Integer类型，默认null），然后返回&amp;&amp;同时递归 BFS, 标准的遍历，记录preNode，在中节点处判断root和pre的大小 235. Lowest Common Ancestor of a BST &amp;&amp; 236. Lowest Common Ancestor of a Binary Tree DFS, 顺序preOrder，传参pq，中节点当判断为Null或者p或者q时，返回root；实例化左右节点递归，最后判断左右null情况返回 Iterative, for BST, 有一种loop做法 12345678910public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;while ((root.val - p.val) * (root.val - q.val) &gt; 0)root = p.val &lt; root.val ? root.left : root.right;return root;&#125; 108. Convert Sorted Array to BST (binary search) DFS, 经典的中点建树问题，BinarySearch，传参lo, hi 109. Convert sorted List to BST 类比108，快慢指针找中点，每次递归找中点，结束条件是fast != tail &amp;&amp; fast.next != null ++注意：递归传参是head和tail，主函数调用时tail为null++ 173. BST iterator inorder 拆开的bfsInorder，每次call next()的时候，做一个while-pushAllLeft，popMid，toRight操作 230. Kth Smallest element in a BST (inorder) BFS, 标准inOrder遍历，每次处理中节点的时候count– 297. Serialize and Deserialize BST (BFS) 用标准的queue level order traversal。==Stack和Queue是可以存放null元素的== 也可以用DFS preOrder，比较快 285. Inorder Sucessor in BST inOrder 前后node的问题，都可以转化为BFS中节点处记录pre的问题。 270. Closest BST value (preorder) 利用BST的性质进行while-loop遍历，更新一个最优值 669. Trim BST 这种题看上去操作很复杂，其实recursive很容易就统解决了，递归返回实例化的TreeNode (root) preOrder DFS，先判断中节点的两种极端情况，直接剪掉一半，然后实例化分别递归root.left和root.right，最后返回root 272. Cloest BST value II (Inorder) 先从上到下按性质走一遍树，双Stack记录大小node。 ++会漏掉一些node，e.g.遇到大的节点时，下一个往左走，那么node.right就漏掉了，反之亦然++ 然后分情况操作small和large stack，先把topNode的下一个漏掉的加进去，然后用while-loop继续添加 99. Recover BST (inorder) 还是利用BST的性质，inOrder BST的结果是一个递增数列，e.g. 1,2,3,4,5 题中说有两个数调换了位置，所以两种情况++1. 相邻 2. 不相邻++ 1. 出现一次pre.val &gt; root.val 2. 出现两次pre.val &gt; root.val 设first, second两个null，第一次更新fisrt，每次都second = root 有些题117. Populating Next Right Pointers in Each Node II 类比P116的满二叉树，本题采用通式，相当于levelOrder Traversal while-loop循环root.next，每次设置一个cur，一个dummy，cur从左向右走，到下一层时root = dummy.next; 314. Binary Tree Vertical order Traversal BFS, levelOrderTraversal, root的index是0，leftNode: index-1, rightNode: index+1 用双Queue配合HashMap做，一个queue存node， 一个queue存index，记录min和max，mapl里每个index对应一个ArrayList 96. Unique Binary search tree (Important) DP问题，==死记硬背==，套公式: F(n) = F(0) * F(n-1) + F(1) * F(n-2) + F(2) * F(n-3) + ... + F(n-2) * F(1) + F(n-1) * F(0) 12345678//累加求DP[n]for(int level = 2; level &lt;=n; level++)for(int root = 1; root&lt;=level; root++)dp[level] += dp[level-root]*dp[root-1]; 156. Binary Tree Upside Down 此题为左单肩树，所有右子树都为叶子或与左子树共用父亲 对于最基本的左中右，upSideDown以后，左.left=中，左.right=右，中.left=中.right=null 可以用BFS和DFS做，参考代码-space)-and-iterative-solutions-(O(1)-space)-with-explanation-and-figure) 114. Flatten Binary Tree to Linked List (seldom) 实际上就是按preOrder的顺序把所有node全都弄到右边 因为此题要求In-Place，所以只能用DFS，建一个全局变量preNode，注意此题在递归的时候先右后左，最后进行root的赋值操作 255. Verify Preorder Sequence in BST (Seldom) 此题默认也是inPlace来做，利用BST的性质，用一个stack来存node.val, 元素比top小的话就push，大的话就先把之前小的都pop出，再存大的，更新minVal，只要新val小于min就一定false 隐藏性质，当遇到比peek值大的元素，说明进入了当前树或者当前子树的right subTree，如果再出现比该值小的则说明false，出现更大的就进入下一个右子树或者大树的右半边树 333. Largest BST subtree (Seldom) - Count Complete Tree Nodes (seldom) Construct Binary Tree From 3种order (seldom) Unique Binary Search Trees II (seldom) Verify Preorder Serialization of a Binary Tree (Seldom)]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[subSet Problems]]></title>
    <url>%2F2018%2F09%2F30%2FsubSet%20Problems%2F</url>
    <content type="text"><![CDATA[大佬总结链接)核心模板123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (nums.length == 0) return res; Arrays.sort(nums);//排序很关键 helper(res, new ArrayList&lt;&gt;(), nums, 0); return res;&#125;//有些需要start，有些不需要private void backtrack(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; temp, int[] nums, int start)&#123; if (满足条件)&#123; res.add(new ArrayList&lt;&gt;(temp)); return; &#125; for (int i = start; i &lt; nums.length; i++)&#123;//构建循环 //1. 是否去重 //2. temp添加元素 //3. 递归调用，param变化 //4. temp去掉末尾元素 &#125;&#125; Subsets Problem==本题求子集，元素数量会变化，所以没有判断条件直接res.add()==LeetCode 78. Subsets 循环start递增12345678private void backtrack(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; LeetCode 90. Subsets II 循环start递增 跳过重复123456789private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; LeetCode 46. Permutations 排列，需要调换顺序，所以从0开始 去重123456789101112private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(tempList.contains(nums[i])) continue; // element already exists, skip tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Permutations II (contains duplicates) 去重，很关键 用used数组辅助1234567891011121314private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, boolean [] used)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i - 1]) continue; used[i] = true; tempList.add(nums[i]); backtrack(list, tempList, nums, used); used[i] = false; tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum1234567891011private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum II (can’t reuse same element) 123456789101112private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i + 1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Palindrome Partitioning12345678910111213public void backtrack(List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; tempList, String s, int start)&#123; if(start == s.length()) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; s.length(); i++)&#123; if(isPalindrome(s, start, i))&#123; tempList.add(s.substring(start, i + 1)); backtrack(list, tempList, s, i + 1); tempList.remove(tempList.size() - 1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>subset</tag>
      </tags>
  </entry>
</search>
